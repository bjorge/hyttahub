// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v3.21.12
// source: allowed_emails_bloc.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "";

/**
 * Fetch the allowed emails for the service or a site
 * The emails are stored outside of the events
 */
export interface AllowedEmailsBlocEvent {
  fetchNow?: AllowedEmailsBlocEvent_FetchedAllowedEmails | undefined;
  updateNow?: AllowedEmailsBlocState | undefined;
}

export interface AllowedEmailsBlocEvent_FetchedAllowedEmails {
}

export interface AllowedEmailsBlocState {
  state: AllowedEmailsBlocState_State;
  emails: { [key: string]: AllowedEmailsBlocState_UserInfo };
}

export enum AllowedEmailsBlocState_State {
  fetching = 0,
  success = 1,
  error = 2,
  permissionDenied = 3,
  UNRECOGNIZED = -1,
}

export function allowedEmailsBlocState_StateFromJSON(object: any): AllowedEmailsBlocState_State {
  switch (object) {
    case 0:
    case "fetching":
      return AllowedEmailsBlocState_State.fetching;
    case 1:
    case "success":
      return AllowedEmailsBlocState_State.success;
    case 2:
    case "error":
      return AllowedEmailsBlocState_State.error;
    case 3:
    case "permissionDenied":
      return AllowedEmailsBlocState_State.permissionDenied;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AllowedEmailsBlocState_State.UNRECOGNIZED;
  }
}

export function allowedEmailsBlocState_StateToJSON(object: AllowedEmailsBlocState_State): string {
  switch (object) {
    case AllowedEmailsBlocState_State.fetching:
      return "fetching";
    case AllowedEmailsBlocState_State.success:
      return "success";
    case AllowedEmailsBlocState_State.error:
      return "error";
    case AllowedEmailsBlocState_State.permissionDenied:
      return "permissionDenied";
    case AllowedEmailsBlocState_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AllowedEmailsBlocState_UserInfo {
  userId: number;
}

export interface AllowedEmailsBlocState_EmailsEntry {
  key: string;
  value?: AllowedEmailsBlocState_UserInfo | undefined;
}

function createBaseAllowedEmailsBlocEvent(): AllowedEmailsBlocEvent {
  return { fetchNow: undefined, updateNow: undefined };
}

export const AllowedEmailsBlocEvent = {
  encode(message: AllowedEmailsBlocEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fetchNow !== undefined) {
      AllowedEmailsBlocEvent_FetchedAllowedEmails.encode(message.fetchNow, writer.uint32(10).fork()).ldelim();
    }
    if (message.updateNow !== undefined) {
      AllowedEmailsBlocState.encode(message.updateNow, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllowedEmailsBlocEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowedEmailsBlocEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fetchNow = AllowedEmailsBlocEvent_FetchedAllowedEmails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateNow = AllowedEmailsBlocState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowedEmailsBlocEvent {
    return {
      fetchNow: isSet(object.fetchNow)
        ? AllowedEmailsBlocEvent_FetchedAllowedEmails.fromJSON(object.fetchNow)
        : undefined,
      updateNow: isSet(object.updateNow) ? AllowedEmailsBlocState.fromJSON(object.updateNow) : undefined,
    };
  },

  toJSON(message: AllowedEmailsBlocEvent): unknown {
    const obj: any = {};
    if (message.fetchNow !== undefined) {
      obj.fetchNow = AllowedEmailsBlocEvent_FetchedAllowedEmails.toJSON(message.fetchNow);
    }
    if (message.updateNow !== undefined) {
      obj.updateNow = AllowedEmailsBlocState.toJSON(message.updateNow);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowedEmailsBlocEvent>, I>>(base?: I): AllowedEmailsBlocEvent {
    return AllowedEmailsBlocEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowedEmailsBlocEvent>, I>>(object: I): AllowedEmailsBlocEvent {
    const message = createBaseAllowedEmailsBlocEvent();
    message.fetchNow = (object.fetchNow !== undefined && object.fetchNow !== null)
      ? AllowedEmailsBlocEvent_FetchedAllowedEmails.fromPartial(object.fetchNow)
      : undefined;
    message.updateNow = (object.updateNow !== undefined && object.updateNow !== null)
      ? AllowedEmailsBlocState.fromPartial(object.updateNow)
      : undefined;
    return message;
  },
};

function createBaseAllowedEmailsBlocEvent_FetchedAllowedEmails(): AllowedEmailsBlocEvent_FetchedAllowedEmails {
  return {};
}

export const AllowedEmailsBlocEvent_FetchedAllowedEmails = {
  encode(_: AllowedEmailsBlocEvent_FetchedAllowedEmails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllowedEmailsBlocEvent_FetchedAllowedEmails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowedEmailsBlocEvent_FetchedAllowedEmails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AllowedEmailsBlocEvent_FetchedAllowedEmails {
    return {};
  },

  toJSON(_: AllowedEmailsBlocEvent_FetchedAllowedEmails): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowedEmailsBlocEvent_FetchedAllowedEmails>, I>>(
    base?: I,
  ): AllowedEmailsBlocEvent_FetchedAllowedEmails {
    return AllowedEmailsBlocEvent_FetchedAllowedEmails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowedEmailsBlocEvent_FetchedAllowedEmails>, I>>(
    _: I,
  ): AllowedEmailsBlocEvent_FetchedAllowedEmails {
    const message = createBaseAllowedEmailsBlocEvent_FetchedAllowedEmails();
    return message;
  },
};

function createBaseAllowedEmailsBlocState(): AllowedEmailsBlocState {
  return { state: 0, emails: {} };
}

export const AllowedEmailsBlocState = {
  encode(message: AllowedEmailsBlocState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    Object.entries(message.emails).forEach(([key, value]) => {
      AllowedEmailsBlocState_EmailsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllowedEmailsBlocState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowedEmailsBlocState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = AllowedEmailsBlocState_EmailsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.emails[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowedEmailsBlocState {
    return {
      state: isSet(object.state) ? allowedEmailsBlocState_StateFromJSON(object.state) : 0,
      emails: isObject(object.emails)
        ? Object.entries(object.emails).reduce<{ [key: string]: AllowedEmailsBlocState_UserInfo }>(
          (acc, [key, value]) => {
            acc[key] = AllowedEmailsBlocState_UserInfo.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: AllowedEmailsBlocState): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = allowedEmailsBlocState_StateToJSON(message.state);
    }
    if (message.emails) {
      const entries = Object.entries(message.emails);
      if (entries.length > 0) {
        obj.emails = {};
        entries.forEach(([k, v]) => {
          obj.emails[k] = AllowedEmailsBlocState_UserInfo.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowedEmailsBlocState>, I>>(base?: I): AllowedEmailsBlocState {
    return AllowedEmailsBlocState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowedEmailsBlocState>, I>>(object: I): AllowedEmailsBlocState {
    const message = createBaseAllowedEmailsBlocState();
    message.state = object.state ?? 0;
    message.emails = Object.entries(object.emails ?? {}).reduce<{ [key: string]: AllowedEmailsBlocState_UserInfo }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AllowedEmailsBlocState_UserInfo.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAllowedEmailsBlocState_UserInfo(): AllowedEmailsBlocState_UserInfo {
  return { userId: 0 };
}

export const AllowedEmailsBlocState_UserInfo = {
  encode(message: AllowedEmailsBlocState_UserInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== 0) {
      writer.uint32(8).int32(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllowedEmailsBlocState_UserInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowedEmailsBlocState_UserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowedEmailsBlocState_UserInfo {
    return { userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0 };
  },

  toJSON(message: AllowedEmailsBlocState_UserInfo): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowedEmailsBlocState_UserInfo>, I>>(base?: I): AllowedEmailsBlocState_UserInfo {
    return AllowedEmailsBlocState_UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowedEmailsBlocState_UserInfo>, I>>(
    object: I,
  ): AllowedEmailsBlocState_UserInfo {
    const message = createBaseAllowedEmailsBlocState_UserInfo();
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseAllowedEmailsBlocState_EmailsEntry(): AllowedEmailsBlocState_EmailsEntry {
  return { key: "", value: undefined };
}

export const AllowedEmailsBlocState_EmailsEntry = {
  encode(message: AllowedEmailsBlocState_EmailsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AllowedEmailsBlocState_UserInfo.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllowedEmailsBlocState_EmailsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowedEmailsBlocState_EmailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AllowedEmailsBlocState_UserInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowedEmailsBlocState_EmailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AllowedEmailsBlocState_UserInfo.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AllowedEmailsBlocState_EmailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AllowedEmailsBlocState_UserInfo.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowedEmailsBlocState_EmailsEntry>, I>>(
    base?: I,
  ): AllowedEmailsBlocState_EmailsEntry {
    return AllowedEmailsBlocState_EmailsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowedEmailsBlocState_EmailsEntry>, I>>(
    object: I,
  ): AllowedEmailsBlocState_EmailsEntry {
    const message = createBaseAllowedEmailsBlocState_EmailsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AllowedEmailsBlocState_UserInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
