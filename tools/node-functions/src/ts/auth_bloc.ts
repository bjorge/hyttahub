// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v3.21.12
// source: auth_bloc.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export enum AuthState {
  /** initializing - transition states (show progress bar) */
  initializing = 0,
  /** authenticating - (logging in) */
  authenticating = 1,
  /** registering - (creating an account) */
  registering = 2,
  submittingEmailVerificationRequest = 3,
  submittingForgottenPasswordRequest = 4,
  submittingSignOutRequest = 5,
  submittingRemoveAccountRequest = 6,
  /** loginSuccess - (login success) */
  loginSuccess = 7,
  /** authenticated - final states (show/push a screen) */
  authenticated = 10,
  /** unauthenticated - (logged out) */
  unauthenticated = 11,
  authenticationError = 12,
  /** emailVerificationSent - (email verification sent during account creation) */
  emailVerificationSent = 13,
  /** forgottenPasswordEmailSent - (password reset email sent) */
  forgottenPasswordEmailSent = 14,
  UNRECOGNIZED = -1,
}

export function authStateFromJSON(object: any): AuthState {
  switch (object) {
    case 0:
    case "initializing":
      return AuthState.initializing;
    case 1:
    case "authenticating":
      return AuthState.authenticating;
    case 2:
    case "registering":
      return AuthState.registering;
    case 3:
    case "submittingEmailVerificationRequest":
      return AuthState.submittingEmailVerificationRequest;
    case 4:
    case "submittingForgottenPasswordRequest":
      return AuthState.submittingForgottenPasswordRequest;
    case 5:
    case "submittingSignOutRequest":
      return AuthState.submittingSignOutRequest;
    case 6:
    case "submittingRemoveAccountRequest":
      return AuthState.submittingRemoveAccountRequest;
    case 7:
    case "loginSuccess":
      return AuthState.loginSuccess;
    case 10:
    case "authenticated":
      return AuthState.authenticated;
    case 11:
    case "unauthenticated":
      return AuthState.unauthenticated;
    case 12:
    case "authenticationError":
      return AuthState.authenticationError;
    case 13:
    case "emailVerificationSent":
      return AuthState.emailVerificationSent;
    case 14:
    case "forgottenPasswordEmailSent":
      return AuthState.forgottenPasswordEmailSent;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuthState.UNRECOGNIZED;
  }
}

export function authStateToJSON(object: AuthState): string {
  switch (object) {
    case AuthState.initializing:
      return "initializing";
    case AuthState.authenticating:
      return "authenticating";
    case AuthState.registering:
      return "registering";
    case AuthState.submittingEmailVerificationRequest:
      return "submittingEmailVerificationRequest";
    case AuthState.submittingForgottenPasswordRequest:
      return "submittingForgottenPasswordRequest";
    case AuthState.submittingSignOutRequest:
      return "submittingSignOutRequest";
    case AuthState.submittingRemoveAccountRequest:
      return "submittingRemoveAccountRequest";
    case AuthState.loginSuccess:
      return "loginSuccess";
    case AuthState.authenticated:
      return "authenticated";
    case AuthState.unauthenticated:
      return "unauthenticated";
    case AuthState.authenticationError:
      return "authenticationError";
    case AuthState.emailVerificationSent:
      return "emailVerificationSent";
    case AuthState.forgottenPasswordEmailSent:
      return "forgottenPasswordEmailSent";
    case AuthState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AuthBlocState {
  authState: AuthState;
  email: string;
  errorMessage: string;
  isServiceAdmin: boolean;
}

export interface AuthBlocEvent {
  emailLogin?: AuthBlocEvent_EmailLogin | undefined;
  emailSignup?: AuthBlocEvent_EmailSignup | undefined;
  emailForgotPassword?: AuthBlocEvent_EmailForgotPassword | undefined;
  logout?: AuthBlocEvent_Logout | undefined;
  startup?: AuthBlocEvent_AppStartup | undefined;
  removeAccount?: AuthBlocEvent_RemoveAccount | undefined;
}

export interface AuthBlocEvent_AppStartup {
}

export interface AuthBlocEvent_EmailLogin {
  email: string;
  password: string;
  language: string;
  serviceAdmin: boolean;
}

export interface AuthBlocEvent_EmailSignup {
  email: string;
  password: string;
  /** string terms = 3; */
  termsVersion: number;
  /** string privacy = 5; */
  privacyVersion: number;
  language: string;
  serviceAdmin: boolean;
}

export interface AuthBlocEvent_EmailForgotPassword {
  email: string;
  language: string;
}

export interface AuthBlocEvent_Logout {
}

export interface AuthBlocEvent_RemoveAccount {
}

function createBaseAuthBlocState(): AuthBlocState {
  return { authState: 0, email: "", errorMessage: "", isServiceAdmin: false };
}

export const AuthBlocState = {
  encode(message: AuthBlocState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.authState !== 0) {
      writer.uint32(8).int32(message.authState);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    if (message.isServiceAdmin !== false) {
      writer.uint32(32).bool(message.isServiceAdmin);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthBlocState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthBlocState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.authState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isServiceAdmin = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthBlocState {
    return {
      authState: isSet(object.authState) ? authStateFromJSON(object.authState) : 0,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      isServiceAdmin: isSet(object.isServiceAdmin) ? globalThis.Boolean(object.isServiceAdmin) : false,
    };
  },

  toJSON(message: AuthBlocState): unknown {
    const obj: any = {};
    if (message.authState !== 0) {
      obj.authState = authStateToJSON(message.authState);
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.isServiceAdmin !== false) {
      obj.isServiceAdmin = message.isServiceAdmin;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthBlocState>, I>>(base?: I): AuthBlocState {
    return AuthBlocState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthBlocState>, I>>(object: I): AuthBlocState {
    const message = createBaseAuthBlocState();
    message.authState = object.authState ?? 0;
    message.email = object.email ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.isServiceAdmin = object.isServiceAdmin ?? false;
    return message;
  },
};

function createBaseAuthBlocEvent(): AuthBlocEvent {
  return {
    emailLogin: undefined,
    emailSignup: undefined,
    emailForgotPassword: undefined,
    logout: undefined,
    startup: undefined,
    removeAccount: undefined,
  };
}

export const AuthBlocEvent = {
  encode(message: AuthBlocEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.emailLogin !== undefined) {
      AuthBlocEvent_EmailLogin.encode(message.emailLogin, writer.uint32(10).fork()).ldelim();
    }
    if (message.emailSignup !== undefined) {
      AuthBlocEvent_EmailSignup.encode(message.emailSignup, writer.uint32(18).fork()).ldelim();
    }
    if (message.emailForgotPassword !== undefined) {
      AuthBlocEvent_EmailForgotPassword.encode(message.emailForgotPassword, writer.uint32(26).fork()).ldelim();
    }
    if (message.logout !== undefined) {
      AuthBlocEvent_Logout.encode(message.logout, writer.uint32(34).fork()).ldelim();
    }
    if (message.startup !== undefined) {
      AuthBlocEvent_AppStartup.encode(message.startup, writer.uint32(42).fork()).ldelim();
    }
    if (message.removeAccount !== undefined) {
      AuthBlocEvent_RemoveAccount.encode(message.removeAccount, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthBlocEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthBlocEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.emailLogin = AuthBlocEvent_EmailLogin.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.emailSignup = AuthBlocEvent_EmailSignup.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.emailForgotPassword = AuthBlocEvent_EmailForgotPassword.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.logout = AuthBlocEvent_Logout.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.startup = AuthBlocEvent_AppStartup.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.removeAccount = AuthBlocEvent_RemoveAccount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthBlocEvent {
    return {
      emailLogin: isSet(object.emailLogin) ? AuthBlocEvent_EmailLogin.fromJSON(object.emailLogin) : undefined,
      emailSignup: isSet(object.emailSignup) ? AuthBlocEvent_EmailSignup.fromJSON(object.emailSignup) : undefined,
      emailForgotPassword: isSet(object.emailForgotPassword)
        ? AuthBlocEvent_EmailForgotPassword.fromJSON(object.emailForgotPassword)
        : undefined,
      logout: isSet(object.logout) ? AuthBlocEvent_Logout.fromJSON(object.logout) : undefined,
      startup: isSet(object.startup) ? AuthBlocEvent_AppStartup.fromJSON(object.startup) : undefined,
      removeAccount: isSet(object.removeAccount)
        ? AuthBlocEvent_RemoveAccount.fromJSON(object.removeAccount)
        : undefined,
    };
  },

  toJSON(message: AuthBlocEvent): unknown {
    const obj: any = {};
    if (message.emailLogin !== undefined) {
      obj.emailLogin = AuthBlocEvent_EmailLogin.toJSON(message.emailLogin);
    }
    if (message.emailSignup !== undefined) {
      obj.emailSignup = AuthBlocEvent_EmailSignup.toJSON(message.emailSignup);
    }
    if (message.emailForgotPassword !== undefined) {
      obj.emailForgotPassword = AuthBlocEvent_EmailForgotPassword.toJSON(message.emailForgotPassword);
    }
    if (message.logout !== undefined) {
      obj.logout = AuthBlocEvent_Logout.toJSON(message.logout);
    }
    if (message.startup !== undefined) {
      obj.startup = AuthBlocEvent_AppStartup.toJSON(message.startup);
    }
    if (message.removeAccount !== undefined) {
      obj.removeAccount = AuthBlocEvent_RemoveAccount.toJSON(message.removeAccount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthBlocEvent>, I>>(base?: I): AuthBlocEvent {
    return AuthBlocEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthBlocEvent>, I>>(object: I): AuthBlocEvent {
    const message = createBaseAuthBlocEvent();
    message.emailLogin = (object.emailLogin !== undefined && object.emailLogin !== null)
      ? AuthBlocEvent_EmailLogin.fromPartial(object.emailLogin)
      : undefined;
    message.emailSignup = (object.emailSignup !== undefined && object.emailSignup !== null)
      ? AuthBlocEvent_EmailSignup.fromPartial(object.emailSignup)
      : undefined;
    message.emailForgotPassword = (object.emailForgotPassword !== undefined && object.emailForgotPassword !== null)
      ? AuthBlocEvent_EmailForgotPassword.fromPartial(object.emailForgotPassword)
      : undefined;
    message.logout = (object.logout !== undefined && object.logout !== null)
      ? AuthBlocEvent_Logout.fromPartial(object.logout)
      : undefined;
    message.startup = (object.startup !== undefined && object.startup !== null)
      ? AuthBlocEvent_AppStartup.fromPartial(object.startup)
      : undefined;
    message.removeAccount = (object.removeAccount !== undefined && object.removeAccount !== null)
      ? AuthBlocEvent_RemoveAccount.fromPartial(object.removeAccount)
      : undefined;
    return message;
  },
};

function createBaseAuthBlocEvent_AppStartup(): AuthBlocEvent_AppStartup {
  return {};
}

export const AuthBlocEvent_AppStartup = {
  encode(_: AuthBlocEvent_AppStartup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthBlocEvent_AppStartup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthBlocEvent_AppStartup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AuthBlocEvent_AppStartup {
    return {};
  },

  toJSON(_: AuthBlocEvent_AppStartup): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthBlocEvent_AppStartup>, I>>(base?: I): AuthBlocEvent_AppStartup {
    return AuthBlocEvent_AppStartup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthBlocEvent_AppStartup>, I>>(_: I): AuthBlocEvent_AppStartup {
    const message = createBaseAuthBlocEvent_AppStartup();
    return message;
  },
};

function createBaseAuthBlocEvent_EmailLogin(): AuthBlocEvent_EmailLogin {
  return { email: "", password: "", language: "", serviceAdmin: false };
}

export const AuthBlocEvent_EmailLogin = {
  encode(message: AuthBlocEvent_EmailLogin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.language !== "") {
      writer.uint32(26).string(message.language);
    }
    if (message.serviceAdmin !== false) {
      writer.uint32(32).bool(message.serviceAdmin);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthBlocEvent_EmailLogin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthBlocEvent_EmailLogin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.language = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.serviceAdmin = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthBlocEvent_EmailLogin {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      serviceAdmin: isSet(object.serviceAdmin) ? globalThis.Boolean(object.serviceAdmin) : false,
    };
  },

  toJSON(message: AuthBlocEvent_EmailLogin): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.serviceAdmin !== false) {
      obj.serviceAdmin = message.serviceAdmin;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthBlocEvent_EmailLogin>, I>>(base?: I): AuthBlocEvent_EmailLogin {
    return AuthBlocEvent_EmailLogin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthBlocEvent_EmailLogin>, I>>(object: I): AuthBlocEvent_EmailLogin {
    const message = createBaseAuthBlocEvent_EmailLogin();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.language = object.language ?? "";
    message.serviceAdmin = object.serviceAdmin ?? false;
    return message;
  },
};

function createBaseAuthBlocEvent_EmailSignup(): AuthBlocEvent_EmailSignup {
  return { email: "", password: "", termsVersion: 0, privacyVersion: 0, language: "", serviceAdmin: false };
}

export const AuthBlocEvent_EmailSignup = {
  encode(message: AuthBlocEvent_EmailSignup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.termsVersion !== 0) {
      writer.uint32(32).int32(message.termsVersion);
    }
    if (message.privacyVersion !== 0) {
      writer.uint32(48).int32(message.privacyVersion);
    }
    if (message.language !== "") {
      writer.uint32(58).string(message.language);
    }
    if (message.serviceAdmin !== false) {
      writer.uint32(64).bool(message.serviceAdmin);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthBlocEvent_EmailSignup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthBlocEvent_EmailSignup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.termsVersion = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.privacyVersion = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.language = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.serviceAdmin = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthBlocEvent_EmailSignup {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      termsVersion: isSet(object.termsVersion) ? globalThis.Number(object.termsVersion) : 0,
      privacyVersion: isSet(object.privacyVersion) ? globalThis.Number(object.privacyVersion) : 0,
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      serviceAdmin: isSet(object.serviceAdmin) ? globalThis.Boolean(object.serviceAdmin) : false,
    };
  },

  toJSON(message: AuthBlocEvent_EmailSignup): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.termsVersion !== 0) {
      obj.termsVersion = Math.round(message.termsVersion);
    }
    if (message.privacyVersion !== 0) {
      obj.privacyVersion = Math.round(message.privacyVersion);
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.serviceAdmin !== false) {
      obj.serviceAdmin = message.serviceAdmin;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthBlocEvent_EmailSignup>, I>>(base?: I): AuthBlocEvent_EmailSignup {
    return AuthBlocEvent_EmailSignup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthBlocEvent_EmailSignup>, I>>(object: I): AuthBlocEvent_EmailSignup {
    const message = createBaseAuthBlocEvent_EmailSignup();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.termsVersion = object.termsVersion ?? 0;
    message.privacyVersion = object.privacyVersion ?? 0;
    message.language = object.language ?? "";
    message.serviceAdmin = object.serviceAdmin ?? false;
    return message;
  },
};

function createBaseAuthBlocEvent_EmailForgotPassword(): AuthBlocEvent_EmailForgotPassword {
  return { email: "", language: "" };
}

export const AuthBlocEvent_EmailForgotPassword = {
  encode(message: AuthBlocEvent_EmailForgotPassword, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.language !== "") {
      writer.uint32(18).string(message.language);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthBlocEvent_EmailForgotPassword {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthBlocEvent_EmailForgotPassword();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthBlocEvent_EmailForgotPassword {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
    };
  },

  toJSON(message: AuthBlocEvent_EmailForgotPassword): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthBlocEvent_EmailForgotPassword>, I>>(
    base?: I,
  ): AuthBlocEvent_EmailForgotPassword {
    return AuthBlocEvent_EmailForgotPassword.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthBlocEvent_EmailForgotPassword>, I>>(
    object: I,
  ): AuthBlocEvent_EmailForgotPassword {
    const message = createBaseAuthBlocEvent_EmailForgotPassword();
    message.email = object.email ?? "";
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseAuthBlocEvent_Logout(): AuthBlocEvent_Logout {
  return {};
}

export const AuthBlocEvent_Logout = {
  encode(_: AuthBlocEvent_Logout, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthBlocEvent_Logout {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthBlocEvent_Logout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AuthBlocEvent_Logout {
    return {};
  },

  toJSON(_: AuthBlocEvent_Logout): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthBlocEvent_Logout>, I>>(base?: I): AuthBlocEvent_Logout {
    return AuthBlocEvent_Logout.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthBlocEvent_Logout>, I>>(_: I): AuthBlocEvent_Logout {
    const message = createBaseAuthBlocEvent_Logout();
    return message;
  },
};

function createBaseAuthBlocEvent_RemoveAccount(): AuthBlocEvent_RemoveAccount {
  return {};
}

export const AuthBlocEvent_RemoveAccount = {
  encode(_: AuthBlocEvent_RemoveAccount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthBlocEvent_RemoveAccount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthBlocEvent_RemoveAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AuthBlocEvent_RemoveAccount {
    return {};
  },

  toJSON(_: AuthBlocEvent_RemoveAccount): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthBlocEvent_RemoveAccount>, I>>(base?: I): AuthBlocEvent_RemoveAccount {
    return AuthBlocEvent_RemoveAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthBlocEvent_RemoveAccount>, I>>(_: I): AuthBlocEvent_RemoveAccount {
    const message = createBaseAuthBlocEvent_RemoveAccount();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
