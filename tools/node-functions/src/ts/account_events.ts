// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v3.21.12
// source: account_events.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export interface AccountEvent {
  version: number;
  initialEvent?: AccountEvent_InitialEvent | undefined;
  terms?:
    | AccountEvent_Terms
    | undefined;
  /** true or false */
  allowEmailNotifications?:
    | boolean
    | undefined;
  /** site id */
  createSite?:
    | string
    | undefined;
  /** the user was removed from this site */
  removeSite?:
    | string
    | undefined;
  /** site id */
  joinSite?:
    | string
    | undefined;
  /** the user left this site */
  leaveSite?: string | undefined;
}

/** these are the terms and policies that the user has accepted */
export interface AccountEvent_Terms {
  termsVersion: number;
  policyVersion: number;
}

export interface AccountEvent_InitialEvent {
  terms?: AccountEvent_Terms | undefined;
  instance: string;
}

/** The SubmitAccountEvent is passed to the submit bloc handler */
export interface SubmitAccountEvent {
  event?:
    | AccountEvent
    | undefined;
  /** the initial site name */
  createSiteName: string;
  /** the user nickname who created the site */
  createSiteUserName: string;
}

/**
 * The AccountEventRecord is a representation of the actual record stored in the
 * database This record is used just for display purposes in the client
 */
export interface AccountEventRecord {
  isoDate: string;
  version: number;
  accountEvent?: AccountEvent | undefined;
}

function createBaseAccountEvent(): AccountEvent {
  return {
    version: 0,
    initialEvent: undefined,
    terms: undefined,
    allowEmailNotifications: undefined,
    createSite: undefined,
    removeSite: undefined,
    joinSite: undefined,
    leaveSite: undefined,
  };
}

export const AccountEvent = {
  encode(message: AccountEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    if (message.initialEvent !== undefined) {
      AccountEvent_InitialEvent.encode(message.initialEvent, writer.uint32(18).fork()).ldelim();
    }
    if (message.terms !== undefined) {
      AccountEvent_Terms.encode(message.terms, writer.uint32(26).fork()).ldelim();
    }
    if (message.allowEmailNotifications !== undefined) {
      writer.uint32(32).bool(message.allowEmailNotifications);
    }
    if (message.createSite !== undefined) {
      writer.uint32(42).string(message.createSite);
    }
    if (message.removeSite !== undefined) {
      writer.uint32(50).string(message.removeSite);
    }
    if (message.joinSite !== undefined) {
      writer.uint32(58).string(message.joinSite);
    }
    if (message.leaveSite !== undefined) {
      writer.uint32(66).string(message.leaveSite);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.initialEvent = AccountEvent_InitialEvent.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.terms = AccountEvent_Terms.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowEmailNotifications = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createSite = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.removeSite = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.joinSite = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.leaveSite = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountEvent {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      initialEvent: isSet(object.initialEvent) ? AccountEvent_InitialEvent.fromJSON(object.initialEvent) : undefined,
      terms: isSet(object.terms) ? AccountEvent_Terms.fromJSON(object.terms) : undefined,
      allowEmailNotifications: isSet(object.allowEmailNotifications)
        ? globalThis.Boolean(object.allowEmailNotifications)
        : undefined,
      createSite: isSet(object.createSite) ? globalThis.String(object.createSite) : undefined,
      removeSite: isSet(object.removeSite) ? globalThis.String(object.removeSite) : undefined,
      joinSite: isSet(object.joinSite) ? globalThis.String(object.joinSite) : undefined,
      leaveSite: isSet(object.leaveSite) ? globalThis.String(object.leaveSite) : undefined,
    };
  },

  toJSON(message: AccountEvent): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.initialEvent !== undefined) {
      obj.initialEvent = AccountEvent_InitialEvent.toJSON(message.initialEvent);
    }
    if (message.terms !== undefined) {
      obj.terms = AccountEvent_Terms.toJSON(message.terms);
    }
    if (message.allowEmailNotifications !== undefined) {
      obj.allowEmailNotifications = message.allowEmailNotifications;
    }
    if (message.createSite !== undefined) {
      obj.createSite = message.createSite;
    }
    if (message.removeSite !== undefined) {
      obj.removeSite = message.removeSite;
    }
    if (message.joinSite !== undefined) {
      obj.joinSite = message.joinSite;
    }
    if (message.leaveSite !== undefined) {
      obj.leaveSite = message.leaveSite;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountEvent>, I>>(base?: I): AccountEvent {
    return AccountEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountEvent>, I>>(object: I): AccountEvent {
    const message = createBaseAccountEvent();
    message.version = object.version ?? 0;
    message.initialEvent = (object.initialEvent !== undefined && object.initialEvent !== null)
      ? AccountEvent_InitialEvent.fromPartial(object.initialEvent)
      : undefined;
    message.terms = (object.terms !== undefined && object.terms !== null)
      ? AccountEvent_Terms.fromPartial(object.terms)
      : undefined;
    message.allowEmailNotifications = object.allowEmailNotifications ?? undefined;
    message.createSite = object.createSite ?? undefined;
    message.removeSite = object.removeSite ?? undefined;
    message.joinSite = object.joinSite ?? undefined;
    message.leaveSite = object.leaveSite ?? undefined;
    return message;
  },
};

function createBaseAccountEvent_Terms(): AccountEvent_Terms {
  return { termsVersion: 0, policyVersion: 0 };
}

export const AccountEvent_Terms = {
  encode(message: AccountEvent_Terms, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.termsVersion !== 0) {
      writer.uint32(8).int32(message.termsVersion);
    }
    if (message.policyVersion !== 0) {
      writer.uint32(16).int32(message.policyVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountEvent_Terms {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountEvent_Terms();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.termsVersion = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.policyVersion = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountEvent_Terms {
    return {
      termsVersion: isSet(object.termsVersion) ? globalThis.Number(object.termsVersion) : 0,
      policyVersion: isSet(object.policyVersion) ? globalThis.Number(object.policyVersion) : 0,
    };
  },

  toJSON(message: AccountEvent_Terms): unknown {
    const obj: any = {};
    if (message.termsVersion !== 0) {
      obj.termsVersion = Math.round(message.termsVersion);
    }
    if (message.policyVersion !== 0) {
      obj.policyVersion = Math.round(message.policyVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountEvent_Terms>, I>>(base?: I): AccountEvent_Terms {
    return AccountEvent_Terms.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountEvent_Terms>, I>>(object: I): AccountEvent_Terms {
    const message = createBaseAccountEvent_Terms();
    message.termsVersion = object.termsVersion ?? 0;
    message.policyVersion = object.policyVersion ?? 0;
    return message;
  },
};

function createBaseAccountEvent_InitialEvent(): AccountEvent_InitialEvent {
  return { terms: undefined, instance: "" };
}

export const AccountEvent_InitialEvent = {
  encode(message: AccountEvent_InitialEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.terms !== undefined) {
      AccountEvent_Terms.encode(message.terms, writer.uint32(10).fork()).ldelim();
    }
    if (message.instance !== "") {
      writer.uint32(18).string(message.instance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountEvent_InitialEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountEvent_InitialEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.terms = AccountEvent_Terms.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountEvent_InitialEvent {
    return {
      terms: isSet(object.terms) ? AccountEvent_Terms.fromJSON(object.terms) : undefined,
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
    };
  },

  toJSON(message: AccountEvent_InitialEvent): unknown {
    const obj: any = {};
    if (message.terms !== undefined) {
      obj.terms = AccountEvent_Terms.toJSON(message.terms);
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountEvent_InitialEvent>, I>>(base?: I): AccountEvent_InitialEvent {
    return AccountEvent_InitialEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountEvent_InitialEvent>, I>>(object: I): AccountEvent_InitialEvent {
    const message = createBaseAccountEvent_InitialEvent();
    message.terms = (object.terms !== undefined && object.terms !== null)
      ? AccountEvent_Terms.fromPartial(object.terms)
      : undefined;
    message.instance = object.instance ?? "";
    return message;
  },
};

function createBaseSubmitAccountEvent(): SubmitAccountEvent {
  return { event: undefined, createSiteName: "", createSiteUserName: "" };
}

export const SubmitAccountEvent = {
  encode(message: SubmitAccountEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.event !== undefined) {
      AccountEvent.encode(message.event, writer.uint32(10).fork()).ldelim();
    }
    if (message.createSiteName !== "") {
      writer.uint32(18).string(message.createSiteName);
    }
    if (message.createSiteUserName !== "") {
      writer.uint32(26).string(message.createSiteUserName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubmitAccountEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitAccountEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.event = AccountEvent.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createSiteName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createSiteUserName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitAccountEvent {
    return {
      event: isSet(object.event) ? AccountEvent.fromJSON(object.event) : undefined,
      createSiteName: isSet(object.createSiteName) ? globalThis.String(object.createSiteName) : "",
      createSiteUserName: isSet(object.createSiteUserName) ? globalThis.String(object.createSiteUserName) : "",
    };
  },

  toJSON(message: SubmitAccountEvent): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = AccountEvent.toJSON(message.event);
    }
    if (message.createSiteName !== "") {
      obj.createSiteName = message.createSiteName;
    }
    if (message.createSiteUserName !== "") {
      obj.createSiteUserName = message.createSiteUserName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitAccountEvent>, I>>(base?: I): SubmitAccountEvent {
    return SubmitAccountEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitAccountEvent>, I>>(object: I): SubmitAccountEvent {
    const message = createBaseSubmitAccountEvent();
    message.event = (object.event !== undefined && object.event !== null)
      ? AccountEvent.fromPartial(object.event)
      : undefined;
    message.createSiteName = object.createSiteName ?? "";
    message.createSiteUserName = object.createSiteUserName ?? "";
    return message;
  },
};

function createBaseAccountEventRecord(): AccountEventRecord {
  return { isoDate: "", version: 0, accountEvent: undefined };
}

export const AccountEventRecord = {
  encode(message: AccountEventRecord, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isoDate !== "") {
      writer.uint32(10).string(message.isoDate);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    if (message.accountEvent !== undefined) {
      AccountEvent.encode(message.accountEvent, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountEventRecord {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountEventRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.isoDate = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountEvent = AccountEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountEventRecord {
    return {
      isoDate: isSet(object.isoDate) ? globalThis.String(object.isoDate) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      accountEvent: isSet(object.accountEvent) ? AccountEvent.fromJSON(object.accountEvent) : undefined,
    };
  },

  toJSON(message: AccountEventRecord): unknown {
    const obj: any = {};
    if (message.isoDate !== "") {
      obj.isoDate = message.isoDate;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.accountEvent !== undefined) {
      obj.accountEvent = AccountEvent.toJSON(message.accountEvent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountEventRecord>, I>>(base?: I): AccountEventRecord {
    return AccountEventRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountEventRecord>, I>>(object: I): AccountEventRecord {
    const message = createBaseAccountEventRecord();
    message.isoDate = object.isoDate ?? "";
    message.version = object.version ?? 0;
    message.accountEvent = (object.accountEvent !== undefined && object.accountEvent !== null)
      ? AccountEvent.fromPartial(object.accountEvent)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
